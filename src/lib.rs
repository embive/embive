//! # Embive (Embedded RISC-V)
//!
//! Embive is a low-level sandboxing library focused on the embedding of untrusted code for constrained environments.  
//! As it interprets RISC-V bytecode, multiple languages are supported out of the box by Embive (Rust, C, C++, Zig, TinyGo, etc.).  
//! By default, it doesnâ€™t require external crates, dynamic memory allocation or the standard library (`no_std` & `no_alloc`).
//!
//! Embive is designed for any error during execution to be recoverable, allowing the host to handle it as needed.
//! As so, no panics should occur on release builds, despite the bytecode being executed.
//!
//! Currently, it supports the `RV32I[MA]Zifencei` unprivileged instruction set (Check [Features](#features)).
//!
//! ## Bytecode
//! The bytecode can be generated by any compiler that supports the RISC-V 32-bit instruction set, as long as it can output a flat
//! binary file (`.bin`) statically linked to the correct addresses (Code at `0x00000000`, RAM at [`crate::memory::RAM_OFFSET`]).
//!
//! ## Example
//!
//! ```
//! use embive::{
//!     engine::{Config, Engine, SYSCALL_ARGS},
//!     memory::{Memory, SliceMemory},
//!     registers::CPURegister,
//! };
//!
//! // A simple syscall implementation. Check [`embive::engine::SyscallFn`].
//! fn syscall<M: Memory>(
//!     nr: i32,
//!     args: &[i32; SYSCALL_ARGS],
//!     memory: &mut M
//! ) -> Result<i32, i32> {
//!     // Match the syscall number
//!     match nr {
//!         1 => Ok(args[0] + args[1]), // Add two numbers (arg[0] + arg[1])
//!         2 => match memory.load(args[0] as u32) { // Load from RAM (arg[0])
//!             Ok(val) => Ok(i32::from_le_bytes(val)), // RISC-V is little endian
//!             Err(_) => Err(1), // Could not read memory
//!         },
//!         _ => Err(2), // Not implemented
//!     }
//! }
//!
//! fn main() {
//!     // "10 + 20" using syscalls (load from ram and add two numbers)
//!     let code = &[
//!         0x93, 0x08, 0x20, 0x00, // li   a7, 2      (Syscall nr = 2)
//!         0x13, 0x05, 0x10, 0x00, // li   a0, 1      (a0 = 1)
//!         0x13, 0x15, 0xf5, 0x01, // slli a0, a0, 31 (a0 << 31) (0x80000000)
//!         0x73, 0x00, 0x00, 0x00, // ecall           (Syscall, load from arg0)
//!         0x93, 0x08, 0x10, 0x00, // li   a7, 1      (Syscall nr = 1)
//!         0x13, 0x05, 0x40, 0x01, // li   a0,20      (a0 = 20)
//!         0x73, 0x00, 0x00, 0x00, // ecall           (Syscall, add two args)
//!         0x73, 0x00, 0x10, 0x00, // ebreak          (Halt)
//!     ];
//!
//!     let mut ram = [0; 1024];
//!     // Store value 10 at RAM address 0 (0x80000000)
//!     ram[..4].copy_from_slice(&u32::to_le_bytes(10));
//!
//!     // Create memory from code and RAM slices
//!     let mut memory = SliceMemory::new(code, &mut ram);
//!
//!     // Create engine config
//!     let config = Config::default().with_syscall_fn(Some(syscall));
//!
//!     // Create engine & run it
//!     let mut engine = Engine::new(&mut memory, config).unwrap();
//!     engine.run().unwrap();
//!
//!     // Check the result (Ok(30))
//!     assert_eq!(
//!         engine.registers.cpu.get(CPURegister::A0 as usize).unwrap(),
//!         0
//!     );
//!     assert_eq!(
//!         engine.registers.cpu.get(CPURegister::A1 as usize).unwrap(),
//!         30
//!     );
//! }
//! ```
//!
//! ## Templates
//! The following templates are available for programs that run inside Embive:
//! - [Rust template](https://github.com/embive/embive-rust-template)
//! - [C/C++ Template](https://github.com/embive/embive-c-template)
//!
//! ## System Calls
//! System calls are a way for the untrusted code to interact with the host environment.
//! When provided to the engine, the system call function will be called when the `ecall` instruction is executed.
//! You can check more information about system calls in the [`engine::SyscallFn`] documentation.
//!
//! ## Features
//! Without any feature enabled, this crates has no external dependencies and can be used in a `no_std` & `no_alloc` environment.
//! Check the available features and their descriptions below:
//!
//! - `m_extension`:
//!     - Enable the RV32M extension (multiply and divide instructions).
//!         - Disabled by default, no additional dependencies.
//! - `a_extension`:
//!     - Enable the RV32A extension (atomic instructions).
//!         - Disabled by default, no additional dependencies.
#![cfg_attr(not(test), no_std)]
pub mod engine;
pub mod error;
mod instruction;
pub mod memory;
pub mod registers;

#[cfg(test)]
mod tests {
    use std::{
        fs::{read_dir, DirEntry},
        path::PathBuf,
    };

    use crate::{
        engine::{Config, Engine, SYSCALL_ARGS},
        memory::{SliceMemory, RAM_OFFSET},
    };

    const RAM_SIZE: usize = 16 * 1024;
    const RV32UI_TESTS: usize = 40;
    #[cfg(feature = "m_extension")]
    const RV32UM_TESTS: usize = 8;
    #[cfg(feature = "a_extension")]
    const RV32UA_TESTS: usize = 10;

    thread_local! {
        static SYSCALL_COUNTER: std::cell::RefCell<i32> = std::cell::RefCell::new(0);
    }

    fn syscall(nr: i32, args: &[i32; SYSCALL_ARGS], _memory: &mut SliceMemory) -> Result<i32, i32> {
        if nr == 93 {
            if args[0] == 0 {
                println!("Test was successful");
            } else {
                panic!("Failed test number: {}", args[0] >> 1);
            }
        } else {
            panic!("Unknown syscall: {}", nr);
        }

        SYSCALL_COUNTER.with(|c| *c.borrow_mut() += 1);
        Ok(0)
    }

    fn execute_bin_test(test: DirEntry) {
        let code = &[];

        println!("\nRunning: {}", test.file_name().to_string_lossy());

        // Load binary into RAM
        let mut ram = [0; RAM_SIZE];
        let test_bytes = std::fs::read(test.path()).expect("Failed to read test file");
        ram[..test_bytes.len()].copy_from_slice(&test_bytes);

        let mut memory = SliceMemory::new(code, &mut ram);

        // Create engine
        let mut engine = Engine::new(
            &mut memory,
            Config {
                syscall_fn: Some(syscall),
                ..Default::default()
            },
        )
        .unwrap();

        // Set program counter to RAM (code start)
        engine.program_counter = RAM_OFFSET;

        // Get syscall counter prior to running
        let prev_syscall_counter = SYSCALL_COUNTER.with(|c| *c.borrow());

        // Run it
        engine.run().unwrap();

        // Get syscall counter after running
        let new_syscall_counter = SYSCALL_COUNTER.with(|c| *c.borrow());

        // Check if syscall was incremented
        if new_syscall_counter <= prev_syscall_counter {
            panic!("No syscall was made");
        }
    }

    #[test]
    fn rv32ui_bin_tests() {
        // Get all tests
        let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        dir.push("tests");
        dir.push("rv32ui");

        let tests = read_dir(dir).expect("Failed to read directory");

        // Iterate over RV32UI tests
        let mut tested_files = 0;
        for test in tests {
            let test = test.expect("Failed to get test");
            execute_bin_test(test);
            tested_files += 1;
        }
        assert_eq!(tested_files, RV32UI_TESTS);
    }

    #[cfg(feature = "m_extension")]
    #[test]
    fn rv32um_bin_tests() {
        // Get all tests
        let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        dir.push("tests");
        dir.push("rv32um");

        let tests = read_dir(dir).expect("Failed to read directory");

        // Iterate over RV32UM tests
        let mut tested_files = 0;
        for test in tests {
            let test = test.expect("Failed to get test");
            execute_bin_test(test);
            tested_files += 1;
        }
        assert_eq!(tested_files, RV32UM_TESTS);
    }

    #[cfg(feature = "a_extension")]
    #[test]
    fn rv32ua_bin_tests() {
        // Get all tests
        let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        dir.push("tests");
        dir.push("rv32ua");

        let tests = read_dir(dir).expect("Failed to read directory");

        // Iterate over RV32UM tests
        let mut tested_files = 0;
        for test in tests {
            let test = test.expect("Failed to get test");
            execute_bin_test(test);
            tested_files += 1;
        }
        assert_eq!(tested_files, RV32UA_TESTS);
    }
}
